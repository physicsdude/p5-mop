#!/usr/bin/env perl
use strict;
use warnings;

use mop::bootstrap;

use mop::internal::instance qw(get_slot_at set_slot_at);
use mop::internal::stashes qw(get_stash_for);

use Storable;

unlink $mop::bootstrap::SERIALIZED_BOOTSTRAP;
mop::bootstrap::init();

my $mop = {
    Object        => $::Object,
    Class         => $::Class,
    Role          => $::Role,
    Method        => $::Method,
    Attribute     => $::Attribute,
    HasMethods    => $::HasMethods,
    HasAttributes => $::HasAttributes,
    HasRoles      => $::HasRoles,
    HasName       => $::HasName,
    HasVersion    => $::HasVersion,
    HasSuperclass => $::HasSuperclass,
    Instantiable  => $::Instantiable,
    Dispatchable  => $::Dispatchable,
    Cloneable     => $::Cloneable,
};

my @methods;
my @attrs;

for my $thing (values %$mop) {
    push @methods, values %{ $thing->local_methods };
    push @attrs,   values %{ $thing->local_attributes };
}

push @methods, grep { defined } map { $_->constructor, $_->destructor }
               $::Class, $::Attribute, $::Method, $::Object, $::Role;

for my $method (@methods) {
    set_slot_at($method, '$body', \'serialize-fix');
}

for my $attr (@attrs) {
    set_slot_at($attr, '$initial_value', \'serialize-fix');
}

for my $class ($::Class, $::Attribute, $::Method, $::Object, $::Role) {
    my $stash = get_stash_for($class);
    # DESTROY calls methods to find DEMOLISH subs, which will break now that we
    # have stripped things out of the mop
    $stash->add_method(DESTROY => sub { });
    # and having overloading enabled makes weird things happen when
    # deserializing
    delete $stash->{'()'};
}

Storable::store($mop, $mop::bootstrap::SERIALIZED_BOOTSTRAP);
