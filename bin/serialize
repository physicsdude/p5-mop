#!/usr/bin/env perl
use strict;
use warnings;

BEGIN { unlink 'lib/mop/bootstrap.mop' }

use mop;

use Storable;

my $mop = {
    Object        => $::Object,
    Class         => $::Class,
    Role          => $::Role,
    Method        => $::Method,
    Attribute     => $::Attribute,
    HasMethods    => $::HasMethods,
    HasAttributes => $::HasAttributes,
    HasRoles      => $::HasRoles,
    HasName       => $::HasName,
    HasVersion    => $::HasVersion,
    HasSuperclass => $::HasSuperclass,
    Instantiable  => $::Instantiable,
    Dispatchable  => $::Dispatchable,
    Cloneable     => $::Cloneable,
};

my @methods;
my @attrs;

for my $thing (values %$mop) {
    push @methods, values %{ $thing->local_methods };
    push @attrs,   values %{ $thing->local_attributes };
}

push @methods, grep { defined } map { $_->constructor, $_->destructor }
               $::Class, $::Attribute, $::Method, $::Object, $::Role;

for my $method (@methods) {
    mop::internal::instance::set_slot_at($method, '$body', \'serialize-fix');
}

for my $attr (@attrs) {
    mop::internal::instance::set_slot_at($attr, '$initial_value', \'serialize-fix');
}

for my $class ($::Class, $::Attribute, $::Method, $::Object, $::Role) {
    my $stash = mop::internal::get_stash_for($class);
    # DESTROY calls methods to find DEMOLISH subs, which will break now that we
    # have stripped things out of the mop
    $stash->add_method(DESTROY => sub { });
    # and having overloading enabled makes weird things happen when
    # deserializing
    delete $stash->{'()'};
}

Storable::store($mop, 'lib/mop/bootstrap.mop');
